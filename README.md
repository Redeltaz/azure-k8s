# Azure k8s

*Dependencies needed to deploy the project + version tested on :*
- *azure-cli 2.54.0*
- *terraform 1.6.1*
- *docker 20.4.7 (& docker-buildx on linux)*
- *kubectl 1.28.2*
- *helm 3.13.12*

When the project is pulled you can follow all this steps :
1. [Deploy the infrastructure](#1-deploy-the-infrastructure)
2. [Build the application](#2-build-the-application)
3. [Deploy the application](#3-deploy-the-application)
4. [Destroy the project](#4-destroy-the-project)

All the commands need to be executed on the route of the directory

<a name="1-deploy-the-infrastructure"></a>
## 1. Deploy the infrastructure

The infrastructure is deployable in Azure using Terraform.

First of all you need to log in to your Azure account using the Azure CLI :
```bash
az login
```

You can now init the Terraform project :
```bash
terraform -chdir=terraform init 
```

And then apply to Azure :
```bash
terraform -chdir=terraform apply --auto-approve
```

Terraform will output the public ip address of the cluster, the kubeconfig file, the name and url of the container registry, we'll use it later.

<a name="2-build-the-application"></a>
## 2. Build the application

The infrastructure is now deployed, we can now build the application using Docker to push it into the Azure Container Registry

First of all you have to export the terraform outputs of useful informations :
```bash
export ACR_URL=$(terraform -chdir=terraform output acr_url | cut -d'"' -f 2)
export ACR_NAME=$(terraform -chdir=terraform output acr_name | cut -d'"' -f 2)
```

After you have to log in to the container registry to be able to push you image inside :
```bash
az acr login --name $ACR_NAME
```

You can now build the docker image :
```bash
cd flask-app && docker build -t $ACR_URL/devops/flask-app . && cd ../
```

And then push the image into the container registry :
```bash
docker push $ACR_URL/devops/flask-app
```

<a name="3-deploy-the-application"></a>
## 3. Deploy the application

Now that the infrastructure is deployed and the app is ready, we can deploy the app inside the AKS cluster.

As seen before, a kubeconfig file was generated in the [/kubernetes](./kubernetes/kubeconfig) folder. 
There is multiple way to change the context of your kubectl client, but in our case we're gonna use a simple kubeconfig file generated by Terraform.

First of all you have to export the terraform output of the public IP of the AKS cluster:
```bash
export AKS_PUBLIC_IP=$(terraform -chdir=terraform output public_ip | cut -d'"' -f 2)
```

You now can deploy all the kubernetes resources :
```bash
kubectl apply -f ./kubernetes/ --recursive --kubeconfig kubernetes/kubeconfig
```

The resources are now all deployed, but you still have to setup the nginx ingress.

First, use helm repository to get ingress-nginx :

```bash
helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx

helm repo update
```

You can now install the ingress-controller in the kubernetes cluster :
```bash
helm install ingress-nginx ingress-nginx/ingress-nginx \
    --kubeconfig kubernetes/kubeconfig \
    --set controller.service.annotations."service\.beta\.kubernetes\.io/azure-load-balancer-health-probe-request-path"=/healthz \
    --set controller.service.loadBalancerIP=$AKS_PUBLIC_IP
```

Everything is now fully deployed, you can test if everything work by using `curl $AKS_PUBLIC_IP` multiple times, the counter should increase.
It may not work instantly, maybe you will have to wait some seconds before it work.

<a name="4-destroy-the-project"></a>
## 4. Destroy the project

To destroy completely the project you can follow this steps :

Delete kubernetes resources :
```bash
kubectl delete -f ./kubernetes/ --recursive --kubeconfig kubernetes/kubeconfig
```

Remove ingress controller :
```bash
helm uninstall ingress-nginx --kubeconfig kubernetes/kubeconfig
```

Destroy all azure resources :
```bash
terraform -chdir=terraform destroy --auto-approve
```
